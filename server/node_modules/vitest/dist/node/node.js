import { builtinModules, createRequire } from 'module';
import { pathToFileURL } from 'url';
import { dirname, resolve, relative } from 'path';
import vm from 'vm';
import { createServer, mergeConfig } from 'vite';
import c from 'picocolors';
const { red, dim, yellow } = c;
const __pendingModules__ = new Map();
export async function run(argv) {
    process.exitCode = 0;
    const root = argv.root || process.cwd();
    process.chdir(root);
    const files = argv.files || argv._;
    argv.shouldExternalize = argv.shouldExternalize || (id => id.includes('/node_modules/'));
    const server = await createServer(mergeConfig(argv.defaultConfig || {}, {
        logLevel: 'error',
        clearScreen: false,
        configFile: argv.config,
        root,
        resolve: {},
    }));
    await server.pluginContainer.buildStart({});
    process.__vite_node__ = {
        server,
        moduleCache: __pendingModules__,
    };
    try {
        await execute(files, server, argv);
    }
    catch (e) {
        process.exitCode = 1;
        throw e;
    }
    finally {
        if (!process.__vite_node__.watch)
            await server.close();
    }
}
function normalizeId(id) {
    // Virtual modules start with `\0`
    if (id && id.startsWith('/@id/__x00__'))
        id = `\0${id.slice('/@id/__x00__'.length)}`;
    if (id && id.startsWith('/@id/'))
        id = id.slice('/@id/'.length);
    return id;
}
function toFilePath(id, server) {
    let absolute = id.startsWith('/@fs/')
        ? id.slice(4)
        : id.startsWith(dirname(server.config.root))
            ? id
            : id.startsWith('/')
                ? slash(resolve(server.config.root, id.slice(1)))
                : id;
    if (absolute.startsWith('//'))
        absolute = absolute.slice(1);
    if (!absolute.startsWith('/'))
        absolute = `/${absolute}`;
    return absolute;
}
async function execute(files, server, options) {
    const result = [];
    for (const file of files)
        result.push(await cachedRequest(`/@fs/${slash(resolve(file))}`, []));
    return result;
    async function directRequest(id, fsPath, callstack) {
        callstack = [...callstack, id];
        const request = async (dep) => {
            if (callstack.includes(dep)) {
                throw new Error(`${red('Circular dependency detected')}\nStack:\n${[...callstack, dep].reverse().map((i) => {
                    const path = relative(server.config.root, toFilePath(normalizeId(i), server));
                    return dim(' -> ') + (i === dep ? yellow(path) : path);
                }).join('\n')}\n`);
            }
            return cachedRequest(dep, callstack);
        };
        const result = await server.transformRequest(id, { ssr: true });
        if (!result)
            throw new Error(`failed to load ${id}`);
        const url = pathToFileURL(fsPath);
        const exports = {};
        const context = {
            require: createRequire(url),
            __filename: fsPath,
            __dirname: dirname(fsPath),
            __vite_ssr_import__: request,
            __vite_ssr_dynamic_import__: request,
            __vite_ssr_exports__: exports,
            __vite_ssr_exportAll__: (obj) => exportAll(exports, obj),
            __vite_ssr_import_meta__: { url },
        };
        const fn = vm.runInThisContext(`async (${Object.keys(context).join(',')}) => { ${result.code} }`, {
            filename: fsPath,
            lineOffset: 0,
        });
        await fn(...Object.values(context));
        return exports;
    }
    async function cachedRequest(rawId, callstack) {
        if (builtinModules.includes(rawId))
            return import(rawId);
        const id = normalizeId(rawId);
        const fsPath = toFilePath(id, server);
        if (options.shouldExternalize(fsPath))
            return import(fsPath);
        if (__pendingModules__.has(fsPath))
            return __pendingModules__.get(fsPath);
        __pendingModules__.set(fsPath, directRequest(id, fsPath, callstack));
        return await __pendingModules__.get(fsPath);
    }
    function exportAll(exports, sourceModule) {
        // eslint-disable-next-line no-restricted-syntax
        for (const key in sourceModule) {
            if (key !== 'default') {
                try {
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        configurable: true,
                        get() { return sourceModule[key]; },
                    });
                }
                catch (_err) { }
            }
        }
    }
}
function slash(path) {
    return path.replace(/\\/g, '/');
}
