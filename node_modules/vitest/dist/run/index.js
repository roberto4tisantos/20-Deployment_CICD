import fg from 'fast-glob';
import { setupChai } from '../integrations/chai/setup';
import { clearContext, defaultSuite } from '../suite';
import { context } from '../context';
import { DefaultReporter } from '../reporters/default';
import { defaultIncludes, defaultExcludes } from '../constants';
import { getSnapshotManager } from '../integrations/chai/snapshot';
async function callHook(suite, name, args) {
    await Promise.all(suite.hooks[name].map(fn => fn(...args)));
}
export async function runTask(task, ctx) {
    var _a, _b, _c;
    const { reporter } = ctx;
    (_a = getSnapshotManager()) === null || _a === void 0 ? void 0 : _a.setTask(task);
    await ((_b = reporter.onTaskBegin) === null || _b === void 0 ? void 0 : _b.call(reporter, task, ctx));
    if (task.mode === 'run') {
        try {
            await callHook(task.suite, 'beforeEach', [task, task.suite]);
            await task.fn();
            task.state = 'pass';
        }
        catch (e) {
            task.state = 'fail';
            task.error = e;
            process.exitCode = 1;
        }
        try {
            await callHook(task.suite, 'afterEach', [task, task.suite]);
        }
        catch (e) {
            task.state = 'fail';
            task.error = e;
            process.exitCode = 1;
        }
    }
    await ((_c = reporter.onTaskEnd) === null || _c === void 0 ? void 0 : _c.call(reporter, task, ctx));
}
export async function collectFiles(paths) {
    const files = {};
    for (const filepath of paths) {
        const file = {
            filepath,
            suites: [],
            collected: false,
        };
        clearContext();
        try {
            await import(filepath);
            const collectors = [defaultSuite, ...context.suites];
            for (const c of collectors) {
                context.currentSuite = c;
                file.suites.push(await c.collect(file));
            }
            file.collected = true;
        }
        catch (e) {
            file.error = e;
            file.collected = false;
            process.exitCode = 1;
        }
        files[filepath] = file;
    }
    const allFiles = Object.values(files);
    const allSuites = allFiles.reduce((suites, file) => suites.concat(file.suites), []);
    interpretOnlyMode(allSuites);
    allSuites.forEach((i) => {
        if (i.mode === 'skip')
            i.tasks.forEach(t => t.mode === 'run' && (t.mode = 'skip'));
        else
            interpretOnlyMode(i.tasks);
        i.tasks.forEach(t => t.mode === 'skip' && (t.state = 'skip'));
    });
    return files;
}
/**
 * If any items been marked as `only`, mark all other items as `skip`.
 */
function interpretOnlyMode(items) {
    if (items.some(i => i.mode === 'only')) {
        items.forEach((i) => {
            if (i.mode === 'run')
                i.mode = 'skip';
            else if (i.mode === 'only')
                i.mode = 'run';
        });
    }
}
export async function runSuite(suite, ctx) {
    var _a, _b;
    const { reporter } = ctx;
    await ((_a = reporter.onSuiteBegin) === null || _a === void 0 ? void 0 : _a.call(reporter, suite, ctx));
    if (suite.mode === 'skip') {
        suite.status = 'skip';
    }
    else if (suite.mode === 'todo') {
        suite.status = 'todo';
    }
    else {
        try {
            await callHook(suite, 'beforeAll', [suite]);
            for (const t of suite.tasks)
                await runTask(t, ctx);
            await callHook(suite, 'afterAll', [suite]);
        }
        catch (e) {
            suite.error = e;
            suite.status = 'fail';
            process.exitCode = 1;
        }
    }
    await ((_b = reporter.onSuiteEnd) === null || _b === void 0 ? void 0 : _b.call(reporter, suite, ctx));
}
export async function runFile(file, ctx) {
    var _a, _b;
    const { reporter } = ctx;
    const runnableSuites = file.suites.filter(i => i.mode === 'run');
    if (runnableSuites.length === 0)
        return;
    await ((_a = reporter.onFileBegin) === null || _a === void 0 ? void 0 : _a.call(reporter, file, ctx));
    if (ctx.config.parallel) {
        await Promise.all(file.suites.map(suite => runSuite(suite, ctx)));
    }
    else {
        for (const suite of file.suites)
            await runSuite(suite, ctx);
    }
    await ((_b = reporter.onFileEnd) === null || _b === void 0 ? void 0 : _b.call(reporter, file, ctx));
}
export async function runFiles(filesMap, ctx) {
    var _a;
    const { reporter } = ctx;
    await ((_a = reporter.onCollected) === null || _a === void 0 ? void 0 : _a.call(reporter, Object.values(filesMap), ctx));
    for (const file of Object.values(filesMap))
        await runFile(file, ctx);
}
export async function run(config) {
    var _a, _b, _c;
    config.reporter = config.reporter || new DefaultReporter();
    const { reporter } = config;
    // if watch, tell `vite-node` not to end the process
    if (config.watch)
        process.__vite_node__.watch = true;
    // setup chai
    await setupChai(config);
    // collect files
    let testFilepaths = await fg(config.includes || defaultIncludes, {
        absolute: true,
        cwd: config.root,
        ignore: config.excludes || defaultExcludes,
    });
    // if name filters are provided by the CLI
    if ((_a = config.filters) === null || _a === void 0 ? void 0 : _a.length)
        testFilepaths = testFilepaths.filter(i => config.filters.some(f => i.includes(f)));
    if (!testFilepaths.length) {
        console.error('No test files found');
        process.exitCode = 1;
        return;
    }
    // setup envs
    if (config.global)
        (await import('../integrations/global')).registerApiGlobally();
    if (config.jsdom)
        (await import('../integrations/jsdom')).setupJSDOM(globalThis);
    await ((_b = reporter.onStart) === null || _b === void 0 ? void 0 : _b.call(reporter, config));
    const filesMap = await collectFiles(testFilepaths);
    const ctx = {
        filesMap,
        get files() {
            return Object.values(this.filesMap);
        },
        get suites() {
            return Object.values(this.filesMap)
                .reduce((suites, file) => suites.concat(file.suites), []);
        },
        get tasks() {
            return this.suites
                .reduce((tasks, suite) => tasks.concat(suite.tasks), []);
        },
        config,
        reporter: config.reporter,
    };
    await runFiles(filesMap, ctx);
    const snapshot = getSnapshotManager();
    snapshot === null || snapshot === void 0 ? void 0 : snapshot.saveSnap();
    snapshot === null || snapshot === void 0 ? void 0 : snapshot.report();
    await ((_c = reporter.onFinished) === null || _c === void 0 ? void 0 : _c.call(reporter, ctx));
    if (config.watch)
        startWatcher(ctx);
}
export async function startWatcher(ctx) {
    var _a, _b;
    await ((_b = (_a = ctx.reporter).onWatcherStart) === null || _b === void 0 ? void 0 : _b.call(_a, ctx));
    let timer;
    const changedTests = new Set();
    const seen = new Set();
    const { server, moduleCache } = process.__vite_node__;
    server.watcher.on('change', async (id) => {
        getDependencyTests(id, ctx, changedTests, seen);
        seen.forEach(i => moduleCache.delete(i));
        seen.clear();
        if (changedTests.size === 0)
            return;
        clearTimeout(timer);
        timer = setTimeout(async () => {
            var _a, _b, _c, _d;
            if (changedTests.size === 0)
                return;
            const snapshot = getSnapshotManager();
            const paths = Array.from(changedTests);
            changedTests.clear();
            await ((_b = (_a = ctx.reporter).onWatcherRerun) === null || _b === void 0 ? void 0 : _b.call(_a, paths, id, ctx));
            paths.forEach(i => moduleCache.delete(i));
            const files = await collectFiles(paths);
            Object.assign(ctx.filesMap, files);
            await runFiles(files, ctx);
            // TODO: clear snapshot state
            snapshot === null || snapshot === void 0 ? void 0 : snapshot.saveSnap();
            snapshot === null || snapshot === void 0 ? void 0 : snapshot.report();
            await ((_d = (_c = ctx.reporter).onWatcherStart) === null || _d === void 0 ? void 0 : _d.call(_c, ctx));
        }, 100);
    });
}
function getDependencyTests(id, ctx, set = new Set(), seen = new Set()) {
    if (seen.has(id) || set.has(id))
        return set;
    seen.add(id);
    if (id in ctx.filesMap) {
        set.add(id);
        return set;
    }
    const mod = process.__vite_node__.server.moduleGraph.getModuleById(id);
    if (mod) {
        mod.importers.forEach((i) => {
            if (i.id)
                getDependencyTests(i.id, ctx, set, seen);
        });
    }
    return set;
}
