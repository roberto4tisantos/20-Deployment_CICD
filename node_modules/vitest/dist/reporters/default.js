/* eslint-disable no-console */
import { performance } from 'perf_hooks';
import { relative } from 'path';
import c from 'picocolors';
import Listr from 'listr';
const CROSS = 'âœ– ';
export class DefaultReporter {
    constructor() {
        this.start = 0;
        this.end = 0;
        this.listr = null;
        this.listrPromise = null;
        this.taskMap = new Map();
    }
    onCollected(files) {
        this.start = performance.now();
        this.taskMap = new Map();
        const tasks = files.reduce((acc, file) => acc.concat(file.suites.flatMap(i => i.tasks)), []);
        tasks.forEach((t) => {
            const obj = {};
            obj.promise = new Promise((resolve, reject) => {
                obj.resolve = resolve;
                obj.reject = reject;
            });
            this.taskMap.set(t, obj);
        });
        const createTasksListr = (tasks) => {
            return tasks.map((task) => {
                return {
                    title: task.name,
                    skip: () => task.mode === 'skip',
                    task: async () => {
                        var _a;
                        return await ((_a = this.taskMap.get(task)) === null || _a === void 0 ? void 0 : _a.promise);
                    },
                };
            });
        };
        const listrOptions = {
            exitOnError: false,
        };
        this.listr = new Listr(files.map((file) => {
            return {
                title: relative(process.cwd(), file.filepath),
                task: () => {
                    if (file.error)
                        throw file.error;
                    const suites = file.suites.filter(i => i.tasks.length);
                    if (!suites.length)
                        throw new Error('No tasks found');
                    return new Listr(suites.flatMap((suite) => {
                        if (!suite.name)
                            return createTasksListr(suite.tasks);
                        return [{
                                title: suite.name,
                                skip: () => suite.mode !== 'run',
                                task: () => new Listr(createTasksListr(suite.tasks), listrOptions),
                            }];
                    }), listrOptions);
                },
            };
        }), listrOptions);
        this.listrPromise = this.listr.run().catch(() => { });
    }
    onTaskEnd(task) {
        var _a, _b;
        if (task.state === 'fail')
            (_a = this.taskMap.get(task)) === null || _a === void 0 ? void 0 : _a.reject(task.error);
        else
            (_b = this.taskMap.get(task)) === null || _b === void 0 ? void 0 : _b.resolve();
    }
    async onFinished(ctx) {
        await this.listrPromise;
        this.end = performance.now();
        console.log();
        const { tasks, suites, files } = ctx;
        const failedFiles = files.filter(i => i.error);
        const failedSuites = suites.filter(i => i.error);
        const runnable = tasks.filter(i => i.state === 'pass' || i.state === 'fail');
        const passed = tasks.filter(i => i.state === 'pass');
        const failed = tasks.filter(i => i.state === 'fail');
        const skipped = tasks.filter(i => i.state === 'skip');
        const todo = tasks.filter(i => i.state === 'todo');
        if (failedFiles.length) {
            console.error(c.bold(`\nFailed to parse ${failedFiles.length} files:`));
            failedFiles.forEach((i) => {
                console.error(c.red(`\n- ${i.filepath}`));
                console.error(i.error || 'Unknown error');
                console.log();
            });
        }
        if (failedSuites.length) {
            console.error(c.bold(c.red(`\nFailed to run ${failedSuites.length} suites:`)));
            failedSuites.forEach((i) => {
                var _a;
                console.error(c.red(`\n- ${(_a = i.file) === null || _a === void 0 ? void 0 : _a.filepath} > ${i.name}`));
                console.error(i.error || 'Unknown error');
                console.log();
            });
        }
        if (failed.length) {
            console.error(c.bold(c.red(`\nFailed Tests (${failed.length})`)));
            failed.forEach((task) => {
                var _a;
                console.error(`\n${CROSS + c.inverse(c.red(' FAIL '))} ${[task.suite.name, task.name].filter(Boolean).join(' > ')} ${c.gray(c.dim(`${(_a = task.file) === null || _a === void 0 ? void 0 : _a.filepath}`))}`);
                console.error(task.error || 'Unknown error');
                console.log();
            });
        }
        console.log(c.bold(c.green(`Passed   ${passed.length} / ${runnable.length}`)));
        if (failed.length)
            console.log(c.bold(c.red(`Failed   ${failed.length} / ${runnable.length}`)));
        if (skipped.length)
            console.log(c.yellow(`Skipped  ${skipped.length}`));
        if (todo.length)
            console.log(c.dim(`Todo     ${todo.length}`));
        console.log(`Time     ${(this.end - this.start).toFixed(2)}ms`);
    }
    async onWatcherStart(ctx) {
        await this.listrPromise;
        const failed = ctx.tasks.filter(i => i.state === 'fail');
        if (failed.length)
            console.log(`\n${c.bold(c.inverse(c.red(' FAIL ')))}${c.red(` ${failed.length} tests failed. Watching for file changes...`)}`);
        else
            console.log(`\n${c.bold(c.inverse(c.green(' PASS ')))}${c.green(' Watching for file changes...')}`);
    }
    async onWatcherRerun(files, trigger) {
        await this.listrPromise;
        console.clear();
        console.log(c.blue('Re-running tests...') + c.dim(` [ ${relative(process.cwd(), trigger)} ]\n`));
    }
    // TODO:
    onSnapshotUpdate() {
    }
}
